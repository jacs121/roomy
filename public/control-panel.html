<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Roomy - Control Panel</title>
    <style>
        body { font-family: Arial, sans-serif; text-align: center; padding: 20px; }
        #clientList, #messages { border: 1px solid #ccc; padding: 10px; margin-top: 10px; max-width: 600px; margin-left: auto; margin-right: auto; }
        .message { display: flex; justify-content: space-between; }
        /* Common Styles */
        :root {
        --primary: #4361ee;
        --secondary: #3f37c9;
        --accent: #4895ef;
        --light: #f8f9fa;
        --dark: #212529;
        --success: #4cc9f0;
        --danger: #f7255a;
        --danger-hover: #f00c32;
        --warning: #f8961e;
        --gray: #6c757d;
        --light-gray: #e9ecef;
        --border: #dee2e6;
        --card-shadow: 0 4px 6px rgba(0,0,0,0.1);
        --transition: all 0.3s ease;
        }

        * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
        }

        body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        background-color: #f5f7fb;
        color: var(--dark);
        line-height: 1.6;
        padding: 20px;
        max-width: 1200px;
        margin: 0 auto;
        }

        h1, h2, h3 {
        color: var(--secondary);
        margin-bottom: 1rem;
        }

        button, input, select {
        font-family: inherit;
        font-size: 1rem;
        }

        button {
        cursor: pointer;
        transition: var(--transition);
        }

        /* Card Styling */
        .card {
        background: white;
        border-radius: 10px;
        box-shadow: var(--card-shadow);
        padding: 1.5rem;
        margin-bottom: 1.5rem;
        }

        /* Form Elements */
        input[type="text"],
        input[type="file"],
        select {
        padding: 0.75rem 1rem;
        border: 1px solid var(--border);
        border-radius: 8px;
        width: 100%;
        transition: var(--transition);
        }

        input:focus, select:focus {
        outline: none;
        border-color: var(--accent);
        box-shadow: 0 0 0 3px rgba(67, 97, 238, 0.1);
        }

        button {
        background-color: var(--primary);
        color: white;
        border: none;
        padding: 0.75rem 1.5rem;
        border-radius: 8px;
        font-weight: 600;
        }

        button:hover {
        background-color: var(--secondary);
        transform: translateY(-2px);
        }

        button:disabled {
        background-color: var(--light-gray);
        cursor: not-allowed;
        transform: none;
        }

        /* ===================== */
        /* CONTROL PANEL SPECIFIC */
        /* ===================== */
        #controls {
        display: grid;
        grid-template-columns: 1fr auto auto;
        gap: 1rem;
        align-items: center;
        margin-bottom: 1.5rem;
        }

        #room-controls {
        display: flex;
        gap: 10px;
        }

        #clientList, #messages {
        background: white;
        border-radius: 10px;
        padding: 1.25rem;
        margin-top: 1rem;
        box-shadow: var(--card-shadow);
        }

        .client-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.75rem 0;
        border-bottom: 1px solid var(--light-gray);
        }

        .client-info {
        font-weight: 600;
        }

        .client-actions {
        display: flex;
        gap: 0.5rem;
        }

        .client-actions button {
        padding: 0.5rem 0.75rem;
        font-size: 0.85rem;
        }

        .delete-btn {
            border: none;
            padding: 5px;
            background-color: var(--danger);
        }
        .delete-btn:hover {
            background-color: var(--danger-hover);
        }

        .message-item {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        padding: 0.75rem 0;
        border-bottom: 1px solid var(--light-gray);
        }

        .message-content {
        flex: 1;
        }

        /* Responsive */
        @media (max-width: 768px) {
        #controls {
            grid-template-columns: 1fr;
        }
        
        #header {
            flex-direction: column;
        }
        
        #input-area {
            flex-direction: column;
        }
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
</head>
<body>

    <h1>Control Panel</h1>
    <input class="controls" type="text" id="newPath" placeholder="New path (e.g. Main/Sub1)">
    <button class="controls" onclick="addRoom()">Add Room</button>
    <select class="controls" id="pathSelect" onchange="fetchRoomData()"></select>
    
    <button onclick="clearMessages()" id="clearMessages" disabled>Clear Messages</button>
    <button onclick="saveChat()" id="saveChat" disabled>Save Chat</button>
    <button onclick="updateClients()" id="updateClients" disabled>Update Clients</button>
    <br>
    <br>
    <input type="number" id="characterLimit" placeholder="character limit" disabled>
    <input type="checkbox" id="anonymous" disabled>anonymous
    <button onclick="updateSettings()" id="updateSettings" disabled>Update Settings</button>

    <h2>Connected Clients</h2>
    <div id="clientList"></div>

    <h2>Chat Messages</h2>
    <div id="messages"></div>

    <script async="true">
        let selectedPath = "room1"
        let timestamp = ""
        marked.use({
            pedantic: false,
            gfm: true,
            break: true
          });

        async function loadPaths() {
            let res = await fetch('/paths', {method: 'GET'});
            let paths = await res.json();
            let pathSelect = document.getElementById('pathSelect');
            function renderPaths(node, prefix = "") {
                return Object.keys(node).map(key => {
                    if (key === "_room_") return "";
                    let newPath = prefix ? `${prefix}/${key}` : key;
                    return `<option value="${newPath}">${newPath}</option>` + renderPaths(node[key], newPath);
                }).join('');
            }
            
            pathSelect.innerHTML = renderPaths(paths);
            pathSelect.value = selectedPath
            if (pathSelect.value === "") return
            if (pathSelect.options.length > 0) {
                document.getElementById("anonymous").disabled = false
                document.getElementById("characterLimit").disabled = false
                document.getElementById("updateSettings").disabled = false
                document.getElementById("clearMessages").disabled = false
                document.getElementById("saveChat").disabled = false
                document.getElementById("updateClients").disabled = false
                fetchRoomData()
            } else {
                document.getElementById("anonymous").disabled = true
                document.getElementById("characterLimit").disabled = true
                document.getElementById("updateSettings").disabled = true
                document.getElementById("clearMessages").disabled = true
                document.getElementById("saveChat").disabled = true
                document.getElementById("updateClients").disabled = true
            }
        }

        async function fetchRoomData() {
            selectedPath = document.getElementById("pathSelect").value;
            if (selectedPath == "") return
            await updateClients();
            await fetchMessages();
        }

        function addRoom() {
            let path = document.getElementById('newPath').value 
            if (path !== "") {
                fetch('/add-room', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ path })
                }).then(loadPaths);
            }
        }


        document.getElementById("anonymous").addEventListener("change", async (event) => {
            
        });

        function updateSettings() {
            let anonymousSetting = document.getElementById("anonymous").checked
            let characterLimitSetting = document.getElementById("characterLimit").value
            fetch(`/anonymous/${selectedPath}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ anonymous: anonymousSetting })
            });

            if (characterLimitSetting) {
                fetch(`/characterLimit/${selectedPath}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ characterLimit: characterLimitSetting })
                });
            }
        }


        async function updateClients() {
            console.log(`/clients/${selectedPath}`)
            await fetch(`/clients/${selectedPath}`, {method: 'GET'})
            .then(async response => {
                let res = await response.json()
                return res
            })
            .then(data => {
                console.log(data)
                const clientListElement = document.getElementById('clientList');
                clientListElement.innerHTML = '';
                for (i=0; i < data.length; i++) {
                    let client = data[i]
                    console.log(client)
                    const div = document.createElement('div');
                    div.innerHTML = `<strong>${client.username}</strong>
                        <button onclick="kickClient('${client.clientId}')">Kick</button>
                        <button onclick="banClient('${client.ip}')">Ban</button>
                        <button onclick="globalBanClient('${client.ip}')">Global Ban</button>`;
                    clientListElement.appendChild(div);
                }
            });
        }

        async function fetchMessages() {
            fetch(`/chat-logs/${selectedPath}`, { method: 'GET' })
            .then(async response => {
                let res = await response.json()
                return res
            })
                .then(data => {
                    document.getElementById("messages").innerHTML = "";
                    timestamp = ""
                    for (i=0; i < data.length; i++) {
                        displayMessage(data[i], i)
                    }
                })
                .catch(error => console.error("Error fetching messages:", error));
        }

        function displayMessage(data, index) {
            const messages = document.getElementById("messages");
            const div = document.createElement('div');
            div.classList.add('message');
            let messageHTML = `<p><strong>[${data.username}] </strong> `;
            if (data.timestamp !== timestamp) {
                div.innerHTML = `<span style="font-size:0.8em;color:gray;">(${data.timestamp})</span>`
            }
            timestamp = data.timestamp

            if (data.type === "file") {
                if (data.fileType.startsWith("image")) {
                    messageHTML += `<br><img src="${data.result}" width="200">`;
                } else if (data.fileType.startsWith("audio")) {
                    messageHTML += `<br><audio controls><source src="${data.result}" type="${data.fileType}"></audio>`;
                } else if (data.fileType.startsWith("video")) {
                    messageHTML += `<br><video width="200" height="200" controls><source src="${data.result}" type="${data.fileType}"></video>`
                } else {
                    messageHTML += `<br><a href="${data.result}" download="${data.filename}">${data.filename}</a>`;
                }
            } else {
                messageHTML += `${marked.parse(data.text)}`;
                messageHTML = messageHTML.slice(0, messageHTML.length-5)
            }
            div.innerHTML += messageHTML+`\t<button class="delete-btn" onclick="deleteMessage(${index})">X</button>`;

            messages.innerHTML += div.innerHTML;
            messages.scrollTop = messages.scrollHeight;
        }

        function banClient(ip) {
            fetch(`/ban-client/${selectedPath}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ ip })
            }).then(() => updateClients());
        }

        function deleteMessage(index) {
            fetch(`/delete-message/${selectedPath}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ index })
            })
            .then(fetchMessages);
        }

        function globalBanClient(ip) {
            fetch(`/gl-ban-client/`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ ip })
            }).then(() => updateClients());
        }

        async function clearMessages() {
            await fetch(`/clear-messages/${selectedPath}`, { method: 'POST' })
                .then(() => document.getElementById('messages').innerHTML = '');
        }

        async function saveChat() {
            await fetch('/save-chat', { method: 'POST' })
                .then(response => response.json())
                .then(data => alert(data.message));
        }



        function kickClient(clientId) {
            console.log(clientId)
            fetch(`/kick-client/${selectedPath}`, {  // Send request with room path
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ clientId })
            })
            .then(response => response.json())
            .then(data => {
                updateClients();  // Refresh the client list
            });
        }
        setInterval(async () => {
            await loadPaths();
            if (pathSelect.options.length > 0) {
                await fetchRoomData()
            }
        }, 5000);
        loadPaths()
        if (pathSelect.options.length > 0) {
            fetchRoomData()
        }
    </script>

</body>
</html>
