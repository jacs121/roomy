<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Socket Chat - Control Panel</title>
    <style>
        body { font-family: Arial, sans-serif; text-align: center; padding: 20px; }
        #clientList, #messages { border: 1px solid #ccc; padding: 10px; margin-top: 10px; max-width: 600px; margin-left: auto; margin-right: auto; }
        .message { display: flex; justify-content: space-between; align-items: center; }
        .delete-btn { background-color: red; color: white; border: none; padding: 5px; cursor: pointer; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
</head>
<body>

    <h1>Control Panel</h1>
    <input type="text" id="newPath" placeholder="New path (e.g. Main/Sub1)">
    <button onclick="addRoom()">Add Room</button>
    <select id="pathSelect" onchange="fetchRoomData()"></select>

    <button onclick="clearMessages()" id="clearMessages" disabled>Clear Messages</button>
    <button onclick="saveChat()" id="saveChat" disabled>Save Chat</button>
    <button onclick="updateClients()" id="updateClients" disabled>Update Clients</button>
    <input type="checkbox" id="anonymous" disabled>anonymous

    <h2>Connected Clients</h2>
    <div id="clientList"></div>

    <h2>Chat Messages</h2>
    <div id="messages"></div>

    <script>
        let selectedPath = ""
        let timestamp = ""
        marked.use({
            pedantic: false,
            gfm: true,
            break: true
          });

        function loadPaths() {
            let res = fetch('/paths', {method: 'GET'});
            let paths = res.json();
            let pathSelect = document.getElementById('pathSelect');
    
            function renderPaths(node, prefix = "") {
                return Object.keys(node).map(key => {
                    if (key === "_room_") return "";
                    let newPath = prefix ? `${prefix}/${key}` : key;
                    return `<option value="${newPath}">${newPath}</option>` + renderPaths(node[key], newPath);
                }).join('');
            }
    
            pathSelect.innerHTML = renderPaths(paths);
            if (pathSelect.options.length > 0) {
                document.getElementById("anonymous").disabled = false
                document.getElementById("clearMessages").disabled = false
                document.getElementById("saveChat").disabled = false
                document.getElementById("updateClients").disabled = false
                fetchRoomData()
            } else {
                document.getElementById("anonymous").disabled = true
                document.getElementById("clearMessages").disabled = true
                document.getElementById("saveChat").disabled = true
                document.getElementById("updateClients").disabled = true
            }
        }

        async function fetchRoomData() {
            selectedPath = document.getElementById("pathSelect").value;
            await updateClients();
            await fetchMessages();
        }

        function addRoom() {
            let path = document.getElementById('newPath').value 
            if (path !== "") {
                fetch('/add-room', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ path })
                }).then(loadPaths);
            }
        }


        document.getElementById("anonymous").addEventListener("change", async (event) => {
            await fetch(`/anonymous/${selectedPath}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ anonymous: event.target.checked })
            });
        });


        async function updateClients() {
            await fetch(`/clients/${selectedPath}`, {method: 'GET'})
            .then(response => response.json())
            .then(data => {
                const clientListElement = document.getElementById('clientList');
                clientListElement.innerHTML = '';
                for (i=0; i < data.length; i++) {
                    let client = data[i]
                    const div = document.createElement('div');
                    div.innerHTML = `<strong>${client.username}</strong>
                        <button onclick="kickClient('${client.clientId}')">Kick</button>
                        <button onclick="banClient('${client.ip}')">Ban</button>
                        <button onclick="globalBanClient('${client.ip}')">GL Ban</button>`;
                    clientListElement.appendChild(div);
                }
            });
        }

        async function fetchMessages() {
            await fetch(`/chat-logs/${selectedPath}`, { method: 'GET' }) // Should be GET, not POST
                .then(res => res.json()) // âœ… Return res.json()
                .then(data => {
                    document.getElementById("messages").innerHTML = "";
                    timestamp = ""
                    for (i=0; i < data.length; i++) {
                        displayMessage(data[i])
                    }
                })
                .catch(error => console.error("Error fetching messages:", error));
        }

        function displayMessage(data) {
            const messages = document.getElementById("messages");
            let messageHTML = `<p><strong>[${data.username}] </strong> `;
            if (data.timestamp !== timestamp) {
                messageHTML = `<span style="font-size:0.8em;color:gray;">(${data.timestamp})</span>` + messageHTML
            }
            timestamp = data.timestamp

            if (data.type === "file") {
                if (data.fileType.startsWith("image")) {
                    messageHTML += `<br><img src="${data.result}" width="200">`;
                } else if (data.fileType.startsWith("audio")) {
                    messageHTML += `<br><audio controls><source src="${data.result}" type="${data.fileType}"></audio>`;
                } else if (data.fileType.startsWith("video")) {
                    messageHTML += `<br><video width="200" height="200" controls><source src="${data.result}" type="${data.fileType}"></video>`
                } else {
                    messageHTML += `<br><a href="${data.result}" download="${data.filename}">${data.filename}</a>`;
                }
            } else {
                messageHTML += `${marked.parse(data.text)}`;
            }

            messageHTML += `</p>`;
            messages.innerHTML += messageHTML;
            messages.scrollTop = messages.scrollHeight;
        }

        function banClient(ip) {
            fetch(`/ban-client/${selectedPath}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ ip })
            }).then(() => updateClients());
        }

        function globalBanClient(ip) {
            fetch(`/gl-ban-client/`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ ip })
            }).then(() => updateClients());
        }

        async function clearMessages() {
            await fetch(`/clear-messages/${selectedPath}`, { method: 'POST' })
                .then(() => document.getElementById('messages').innerHTML = '');
        }

        async function saveChat() {
            await fetch('/save-chat', { method: 'POST' })
                .then(response => response.json())
                .then(data => alert(data.message));
        }



        function kickClient(clientId) {
            fetch(`/kick-client/${selectedPath}`, {  // Send request with room path
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ clientId })
            })
            .then(response => response.json())
            .then(data => {
                console.log(data.message);
                updateClients();  // Refresh the client list
            });
        }
        setInterval(() => {
            loadPaths();
            if (pathSelect.options.length > 0) {
                fetchRoomData()
            }
        }, 5000);
        loadPaths();
        if (pathSelect.options.length > 0) {
            fetchRoomData()
        }
    </script>

</body>
</html>
